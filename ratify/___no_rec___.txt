use std::collections::HashMap;
use std::collections::HashSet;
use std::hash::Hash;
use std::io::{self, BufRead,Write};

#[derive(Clone, PartialEq)]
enum Expression {
    //Env(Environment),
    Stack(Vec<Expression>),
    List(Vec<Expression>),
    Word(String),
    Void
}

trait Apply {
    fn box_clone(&self) -> Box<dyn Apply>;
    fn call_on(&self, env: &mut Environment);
}

impl <F: Fn(&mut Environment) -> () + Clone + 'static> Apply for F {
    fn box_clone(&self) -> Box<dyn Apply> {
        Box::new(self.clone())
    }
    fn call_on(&self, env: &mut Environment) {
        self(env)
    }
}

impl Clone for Box<dyn Apply> {
    fn clone(&self) -> Self {
        self.box_clone()
    }
}

#[derive(Clone)]
struct Condout {
    cond: Vec<Expression>,
    out: Vec<Expression>
}

#[derive(Clone)]
struct Function {
    closure: Box<dyn Apply>,
    parameters: Vec<Expression>,
    name: String,
    condouts: Vec<Condout>,
    specification: Vec<Expression>,
    is_removable: bool
}

struct Error {
    msg: Vec<Expression>
}

enum ErrType {
    SpecLength,
    ParamList,
    ParamDup,
    FnName,
    ConOutList,
    ConOutLength
}

#[derive(Clone)]
struct Environment {
    program: Vec<Expression>,
    functions: HashMap<String, Function>,
    stack: Vec<Expression>
}

fn generate_environment(prog: Vec<Expression>,fns: HashMap<String, Function>) -> Environment {
    Environment {
        program: prog,
        functions: fns,
        stack: vec![]
    }
}

fn repeat_char(chr: char, n: u32) -> String {
    let mut line = String::from("");
    for _ in 0..n {
        line.push(chr);
    }

    line
}

fn read_user_input(leave_on_count: usize) -> String {
    std::io::stdout().flush().expect("Idk what happened here...");
    let mut content = String::new();
    
    let mut newline_count = 0;
    for line in io::stdin().lock().lines() {
        let unwrapped_line = line.unwrap();
        if unwrapped_line.len() == 0 {
            newline_count += 1;
        } else {
            newline_count = 0;
        }

        content.push_str(unwrapped_line.as_str());
        content.push(' '); //between the lines

        if newline_count == leave_on_count {
            break;
        }

        // content.push_str(unwrapped_line.as_str());
        // content.push(' '); //between the lines
    }

    content
}

fn from_input(n: usize) -> Vec<char> {
    let mut input_chars: Vec<char> = read_user_input(n).chars().collect();
    input_chars.reverse();
    input_chars
}

fn push_token(token: &mut String, v: &mut Vec<Expression>) {
    if token.len() > 0 {
        v.push(Expression::Word(String::from(&*token)));
        *token = String::new();
    }
}

fn build_expression_list(input_chars: &mut Vec<char>) -> Vec<Expression> {
    let mut program_stack: Vec<Vec<Expression>> = vec![vec![]];
    let mut token = String::new();

    let mut pnt = program_stack.len() - 1;
    while input_chars.len() > 0 {
        let c = input_chars.pop().unwrap();
        let last_c = match token.clone().chars().last() {
            Some(ch) => ch,
            _ => 'N'
        };

        if c.is_whitespace() {
            push_token(&mut token, &mut program_stack[pnt]);
        } else if c == '(' {
            if last_c == '\\' {
                token.push(c);
            } else {
                push_token(&mut token, &mut program_stack[pnt]);

                program_stack.push(vec![]);
            }
        } else if c == ')' {
            if last_c == '\\' {
                token.push(c);
            } else if program_stack.len() > 1 {
                push_token(&mut token, &mut program_stack[pnt]);
                
                let list = program_stack.pop().unwrap();
                program_stack[pnt-1].push(Expression::List(list));
            } else {
                push_token(&mut token, &mut program_stack[pnt]);

                program_stack[pnt].push(Expression::Word(String::from("\\)")));
            }
        } else {
            token.push(c);
        }

        pnt = program_stack.len() - 1;
    }

    push_token(&mut token, &mut program_stack[pnt]);

    while program_stack.len() > 1 {
        pnt = program_stack.len() - 1;

        let mut non_list = program_stack.pop().unwrap();
        program_stack[pnt-1].push(Expression::Word(String::from("\\(")));
        program_stack[pnt-1].append(&mut non_list);
    }

    program_stack.pop().unwrap()
}

fn tester() {
    let close: Box<dyn Apply> = Box::new(
        |env: &mut Environment| {
            for x in &env.stack {
                match x {
                    //Expression::Env(_) => println!("Found environment."),
                    Expression::Stack(_) => println!("Found stack."),
                    Expression::List(_) => println!("Found list."),
                    Expression::Word(txt) => println!("Found {}!", txt),
                    Expression::Void => println!("Found...")
                }
            }
        }
    );

    close.call_on(
        &mut Environment {
            program: vec![],
            functions: HashMap::new(),
            stack: vec![
                // Expression::Env(
                //     Environment {
                //         program: vec![],
                //         functions: HashMap::new(),
                //         stack: vec![]
                //     }
                // ),
                Expression::Stack(vec![]),
                Expression::List(vec![]),
                Expression::Word(String::from("Hello Word!")),
                Expression::Void
            ]
        }
    );
}

fn ratify_implementation_error() -> String {
    String::from("Ratify implementation error!\n")
}

fn expected_word_or_list_not(this_expression: &str) -> String {
    ratify_implementation_error()
    + "\tExpected 'Word' or 'List', found '"
    + this_expression
    + "'."
}

fn generate_error(etype: ErrType, code: Vec<Expression>) -> Error {
    let mut err_msg = build_expression_list(
        &mut String::from("Invalid Function Spec: ").chars().collect()
    );
    err_msg.append(&mut code.clone());

    match etype {
        ErrType::SpecLength => {
            err_msg.append(&mut build_expression_list(
                &mut String::from("Spec must contain more
                than 2 expressions").chars().collect()
            ));   
        },
        ErrType::ParamList => {
            err_msg.append(&mut build_expression_list(
                &mut String::from("Parameters must be specified in
                a list, found word").chars().collect()
            ));
        },
        ErrType::ParamDup => {
            err_msg.append(&mut build_expression_list(
                &mut String::from("Parameter list contains
                duplicate names").chars().collect()
            ));
        },
        ErrType::FnName => {
            err_msg.append(&mut build_expression_list(
                &mut String::from("Function name must be
                a word,found list").chars().collect()
            ));
        },
        ErrType::ConOutList => {
            err_msg.append(&mut build_expression_list(
                &mut String::from("A Condition and Output must be
                specified in a list, found word").chars().collect()
            ));
        },
        ErrType::ConOutLength => {
            err_msg.append(&mut build_expression_list(
                &mut String::from("Non empty conditions must contain
                as many expressions as in the parameter list").chars().collect()
            ));
        }
    }

    Error {
        msg: err_msg
    }
}

fn check_specification_length_of(function: Function) -> Result<Function,Error> {
    let spec_len = function.specification.len();
    if spec_len > 2 {
        Ok(function)
    } else {
        Err(generate_error(ErrType::SpecLength, function.specification))
    }
}

fn check_for_parameter_list(function: Function) -> Result<Function,Error> {
    match &function.specification[0] {
        Expression::Stack(_) => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
        Expression::List(lst) => {
            Ok(Function {
                parameters:     lst.to_vec(),
                name:           String::from("<>"),
                condouts:       vec![],
                specification:  function.specification,
                is_removable:   false,
                closure:        Box::new(|_env: &mut Environment| {})
            })
        },
        Expression::Word(_) => {
            Err(generate_error(ErrType::ParamList, function.specification))
        },
        Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
    }
}

fn flatten_and_insert(params: Vec<Expression>, nested: bool) -> Vec<String> {
    let mut flat_vec: Vec<String> = vec![];
    for expr in params {
        match &expr {
            Expression::Stack(_) => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
            Expression::List(vexpr) => {
                let mut sub_vec = flatten_and_insert(vexpr.to_vec(), true);
                flat_vec.append(&mut sub_vec);
            },
            Expression::Word(wrd) => {
                if nested {
                    flat_vec.push(String::from(wrd));
                    flat_vec.push(String::from("_") + wrd);
                } else {
                    flat_vec.push(String::from(wrd));
                }
            },
            Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
        }
    }

    flat_vec
}

fn has_unique_elements<T>(iter: T) -> bool
where
    T:IntoIterator,
    T::Item :Eq + Hash,
{
    let mut uniq = HashSet::new();
    iter.into_iter().all(move |x| uniq.insert(x))
}

fn check_for_duplicate_parameter_names(function: Function) -> Result<Function,Error> {
    let flat_param_list = flatten_and_insert(function.parameters.to_vec(), false);
    
    if has_unique_elements(flat_param_list) {
        Ok(function)
    } else {
        Err(generate_error(ErrType::ParamDup, function.specification))
    }
}

fn check_for_valid_function_name(function: Function) -> Result<Function,Error> {
    //A valid function name must be a word
    match &function.specification[1] {
        Expression::Stack(_) => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
        Expression::List(_) => {
            Err(generate_error(ErrType::FnName, function.specification))
        },
        Expression::Word(wrd) => {
            Ok(Function {
                parameters:     function.parameters,
                name:           String::from(wrd),
                condouts:       vec![],
                specification:  function.specification,
                is_removable:   false,
                closure:        Box::new(|_env: &mut Environment| {})
            })
        },
        Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
    }
}

fn generate_condout(param_len: usize, vex: Vec<Expression>) -> Option<Condout> {
    let mut condition: Vec<Expression> = vec![];
    let mut output: Vec<Expression> = vec![];
    
    let mut delimiter_found = false;

    for expr in vex {
        match &expr {
            Expression::Stack(_) => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
            Expression::List(_) => {
                if delimiter_found {
                    output.push(expr);
                } else {
                    condition.push(expr);
                }
            },
            Expression::Word(wrd) => {
                if delimiter_found {
                    output.push(expr);
                } else if wrd == "->" {
                    delimiter_found = true;
                    continue;
                } else {
                    condition.push(expr);
                }
            },
            Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
        }
    }

    if delimiter_found {
        ()
    } else {
        output = condition;
        condition = vec![];
    }

    //A valid condition cannot have fewer expressions than there are parameters
    // if the condition is not empty
    let cond_len = condition.len();
    if cond_len > 0 && (cond_len != param_len) {
        return None
    } else {
        return 
        Some(Condout {
            cond: condition,
            out: output
        })
    }
}

fn check_for_valid_condouts(function: Function) -> Result<Function,Error> {
    let mut cndouts: Vec<Condout> = vec![];

    let mut iterator = 0;
    for expr in &function.specification {
        if iterator > 1 {
            //A valid condout must be a list
            match &expr {
                Expression::Stack(_) => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
                Expression::List(lst) => {
                    match generate_condout(function.parameters.len(), lst.clone()) {
                        Some(condout) => cndouts.push(condout),
                        None => {
                            return Err(generate_error(ErrType::ConOutLength, function.specification))
                        }
                    }
                },
                Expression::Word(_) => {
                    return Err(generate_error(ErrType::ConOutList, function.specification))
                },
                Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
            }
        }
        iterator += 1;
    }

    Ok(Function{
        parameters:     function.parameters,
        name:           function.name,
        condouts:       cndouts,
        specification:  function.specification,
        is_removable:   false,
        closure:        Box::new(|_env: &mut Environment| {})
    })
}

fn only_returns_function_name_of(function: &Function) -> bool {
    let condout = &function.condouts[0];
    if condout.cond.len() == 0 
    && condout.out.len() > 0 
    && condout.out.len() < 2 {
        match &condout.out[0] {
            Expression::Stack(_) => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
            Expression::List(_) => false,
            Expression::Word(wrd) => {
                if wrd == &function.name {
                    true
                } else {
                    false
                }
            },
            Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
        }
    } else {
        false
    }
}

fn check_for_removability(function: Function) -> Result<Function,Error> {
    let mut is_rem = false;

    //If there are zero input parameters, no conditions, and only
    //  one output that contains the function name, then the function
    //  is removable from the function dictionary
    if function.parameters.len() == 0
    && function.condouts.len() == 1
    && only_returns_function_name_of(&function) {
        is_rem = true;
    }

    Ok(Function{
        parameters:     function.parameters,
        name:           function.name,
        condouts:       function.condouts,
        specification:  function.specification,
        is_removable:   is_rem,
        closure: Box::new(|_env: &mut Environment| {})
    })
}

fn grant_closure(function: Function) -> Result<Function,Error> {
    let new_closure: Box<dyn Apply> = Box::new(
        |_env: &mut Environment| {
            
        }
    );

    Ok(Function{
        parameters:     function.parameters,
        name:           function.name,
        condouts:       function.condouts,
        specification:  function.specification,
        is_removable:   function.is_removable,
        closure:        new_closure
    })
}

fn functionable(function: Function) -> Result<Function,Error> {
    check_specification_length_of(function)
    .and_then(check_for_parameter_list)
    .and_then(check_for_duplicate_parameter_names)
    .and_then(check_for_valid_function_name)
    .and_then(check_for_valid_condouts)
    .and_then(check_for_removability)
    .and_then(grant_closure)
}

fn generate_function(environment: &mut Environment, fn_spec: Vec<Expression>) {
    let function = Function {
        parameters:     vec![],
        name:           String::from("<>"),
        condouts:       vec![],
        specification:  fn_spec,
        is_removable:   false,
        closure:        Box::new(|_env: &mut Environment| {})
    };

    let new_function: Result<Function,Error> = functionable(function);

    match new_function {
        Ok(valid_function) => {
            if valid_function.name == "->" {
                valid_function.closure.call_on(environment);
            } else if valid_function.is_removable
            && environment.functions.contains_key(&valid_function.name) {
                environment.functions.remove(&valid_function.name);
            } else {
                environment.functions.insert(valid_function.name.clone(), valid_function);
            }
        },
        Err(error) => {
            environment.stack.push(Expression::List(error.msg))
        }
    }
}

fn define(environment: &mut Environment) -> (Environment, bool) {
    if environment.stack.len() == 0 {
        return (generate_environment(vec![], HashMap::new()), false)
    }

    let expr = environment.stack.pop().unwrap();
    match &expr {
        Expression::Stack(_) => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
        Expression::List(function_spec) => {
            generate_function(environment, function_spec.to_vec());
            return (generate_environment(vec![], HashMap::new()), false)
        },
        Expression::Word(wrd) => {
            if wrd == "->" {
                environment.stack.push(expr);//remove
                //return stitch_or_rip(environment)
                return (generate_environment(vec![], HashMap::new()), false)//remove
            } else {
                match environment.functions.get(wrd) {
                    Some(function) => environment.stack.push(Expression::List(function.specification.to_vec())),
                    _ => environment.stack.push(expr)
                }

                return (generate_environment(vec![], HashMap::new()), false)
            }
        },
        Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
    }
}

fn call(environment: &mut Environment) -> (Environment, bool) {
    if environment.stack.len() == 0 {
        return (generate_environment(vec![], HashMap::new()), false)
    }

    let expr = environment.stack.pop().unwrap();
    match expr {
        Expression::Stack(_) => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
        Expression::List(lst) => {
            return (generate_environment(lst, environment.functions.clone()), true)
        },
        Expression::Word(wrd) => {
            if wrd == "->" {
                return define(environment)
            } else if environment.functions.contains_key(&wrd) {
                let function = environment.functions.get(&wrd).unwrap().clone();
                function.closure.call_on(environment);
                return (generate_environment(vec![], HashMap::new()), false)
            } else {
                environment.stack.push(Expression::Word(String::from(wrd)));
                return (generate_environment(vec![], HashMap::new()), false)
            }
        },
        Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
    }
}

fn evaulate_program(environment_stack: &mut Vec<Environment>) {
    let mut pnt = environment_stack.len() - 1;
    environment_stack[0].program.reverse();

    while environment_stack[pnt].program.len() > 0 {
        let expr = environment_stack[pnt].program.pop().unwrap();

        match &expr {
            Expression::Stack(_)  => panic!("\n\n{}\n\n", expected_word_or_list_not("Stack")),
            Expression::List(_)   => environment_stack[pnt].stack.push(expr),
            Expression::Word(wrd) => {
                if wrd == "@" {
                    let (mut new_env, new_evn_is_needed) = call(&mut environment_stack[pnt]);
                    if new_evn_is_needed {
                        new_env.program.reverse();
                        environment_stack.push(new_env);
                        pnt = environment_stack.len() - 1;
                    }
                } else {
                    environment_stack[pnt].stack.push(expr);
                }
            },
            Expression::Void => panic!("\n\n{}\n\n", expected_word_or_list_not("Void"))
        }

        if pnt > 0 && environment_stack[pnt].program.len() == 0 {
            let list = environment_stack.pop().unwrap().stack;
            environment_stack[pnt-1].stack.push(Expression::List(list));
        }
        pnt = environment_stack.len() - 1;
    }

    if environment_stack.len() != 1 {
        panic!("\n\nEnvironment stack did not reduce to the root environment.
        One environment was expected, found: {}\n\n"
        , environment_stack.len())
    }
}

fn repl() {
    let mut environment_stack = vec![generate_environment(vec![], HashMap::new())]; 
    loop {
        println!("-------<<<INPUT>>>-------{}Write code, then press 'Enter' three times", repeat_char(' ', 15));
        environment_stack[0].program = build_expression_list(&mut from_input(2));
        
        println!("-------<<<CONSOLE>>>-------");
        evaulate_program(&mut environment_stack);
        println!("\n\n");
        
        println!("-------<<<STACK>>>-------");
        //print stack
        println!("\n\n");
    }
}

fn main() {
    repl();
}